## 1. **비관적 락 (Pessimistic Locking)**
동시성 충돌이 자주 발생할 것이라고 가정하고, 데이터에 접근할 때마다 미리 락을 걸어 다른 트랜잭션의 접근을 차단하는 방식입니다.

### 핵심 개념
***비관적 락*** 은 동시성 문제를 막기 위해 미리 락을 설정하는 전략 전체를 의미하며, 그 내부에 배타적 락과 공유 락이 포함됩니다.

_**배타적 락(Exclusive Lock)**_ 은 쓰기하는 동안 데이터를 독점하는 락 자체를 뜻하며, **PESSIMISTIC_WRITE 모드**가 이에 해당합니다.

### 동작 방식
- 데이터에 배타적 락을 걸어 다른 트랜잭션의 읽기와 쓰기를 모두 차단합니다
- SQL 로는 `SELECT ... FOR UPDATE `쿼리가 실행됩니다
- 락을 획득한 트랜잭션만 해당 데이터에 접근 가능합니다
- 트랜잭션이 커밋되거나 롤백될 때까지 락이 유지됩니다

### 예시 코드
~~~ java
    @Lock(LockModeType.PESSIMISTIC_WRITE) // JPA에서 비관적 락 설정
    @Query("SELECT s FROM Stock s WHERE s.id = :id")
    Optional<Stock> findByIdWithPessimisticLock(Long id);
~~~

### 실제 실행 쿼리
~~~ sql
SELECT s1_0.id,s1_0.product_id,s1_0.quantity
FROM stock s1_0
WHERE s1_0.id=?
FOR UPDATE -- - FOR UPDATE가 있으면 조회한 행에 **배타적 락(Exclusive Lock)** 을 겁니다.
~~~


## 2. **낙관적 락 (Optimistic Locking)**
낙관적 락은 동시성 충돌이 드물게 발생한다고 가정하고, 데이터를 수정할 때만 충돌 여부를 검사하는 방식입니다.

### 핵심 개념
- 낙관적 락은 데이터를 읽을 때는 락을 걸지 않고, **_업데이트 시점에만 이전 데이터와 현재 데이터의 버전(or 타임스탬프 등)을 비교_** 하여 충돌 여부를 판단합니다.
- 충돌이 있을 경우, 갱신을 거부하거나 **_재시도 로직_** 을 실행합니다.
- 락은 DB가 아닌` 애플리케이션/ORM/JPA` 에서 관리합니다.
- @Version과 같은 버전 컬럼을 활용해 동시성 문제를 감지하게 만듭니다.

### 동작 방식
- 데이터 읽을 때는 락을 걸지 않음.
- 수정/커밋 시점에 버전을 비교하여 동일 버전에만 커밋 허용.
- 다른 트랜잭션이 먼저 커밋했다면, 충돌이 감지되어 커밋이 실패함.

### 예시 코드
~~~ java
@Entity
public class Stock {
    @Version // 낙관적 락을 위한 버전 관리용 필드
    private Long version;

    // 필드, getter/setter 등
}
~~~
- 별도의 옵션을 사용하지 않아도 Entity에 @Version이 적용된 필드만 있으면 낙관적 락이 적용됩니다.

### 실제 실행 쿼리
```sql
UPDATE stock
SET quantity = ?, version = ?
WHERE id = ? AND version = ?  -- 기준 버전 값 확인
```

### 재시도 로직
```java
 /**
     * * 낙관적 락 실패 시 재시도 로직
     **/
    public void decrease(Long id, Long quantity) throws InterruptedException {
        while (true) {
            try {
                stockService.decrease(id, quantity);
                break;
            } catch (ObjectOptimisticLockingFailureException e) {
                Thread.sleep(50);
            }
        }
    }

```
## JPA 에서의 @Version과 @Lock(LockModeType.OPTIMISTIC)
### @Version만 사용하는 경우
  - @Version 어노테이션을 엔티티에 붙이면, 엔티티가 수정할 때만 버전 정보를 이용해 충돌을 감지합니다.
```java
@Entity
public class Stock {
    @Id
    private Long id;
    
    private Long quantity;
    
    @Version
    private Long version;
}
```
- **동작**: 엔티티를 수정하고 커밋할 때, JPA가 다음 쿼리를 실행합니다
```sql
UPDATE stock SET quantity = ?, version = version + 1 
WHERE id = ? AND version = ?
```
**조회 후 변경사항 감지 불가**: `@Version` 만으로는 조회 후 다른 트랜잭션의 변경을 감지할 수 없습니다. 수정이 발생하지 않으면 버전을 체크하지 않기 때문입니다.

### @Version + @Lock(LockModeType.OPTIMISTIC) 사용
- **LockModeType.OPTIMISTIC**을 추가하면, 조회 시점부터 커밋 시점까지 데이터의 변경을 감지합니다.
- 이렇게 하면 **_읽기 트랜잭션 동안에 다른 트랜잭션이 데이터를 변경_** 할 수 없도록 하여 더 강한 일관성을 보장할 수 있습니다.

```java
@Lock(LockModeType.OPTIMISTIC)
@Query("select s from Stock s where s.id = :id")
Stock findByIdWithLock(@Param("id") Long id);
```
**동작**: 엔티티를 조회하면 버전을 기록하고, 커밋 시점에 버전이 변경되었는지 확인합니다. 수정이 없어도 버전 체크가 이루어집니다.
#### 정리
- `@Version` 만으로 충분한 경우: 조회한 엔티티를 반드시 수정하는 경우입니다.

- @Lock(LockModeType.OPTIMISTIC) 필요한 경우: 조회만 하고 수정하지 않거나, 조회한 데이터가 트랜잭션 중간에 변경되면 안 되는 경우